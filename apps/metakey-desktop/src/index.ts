import { app, BrowserWindow, screen, ipcMain } from 'electron';
import { spawn } from 'child_process';
import path from 'path';
import { ClipboardService } from 'clipboard-engine';
import {
  SpellService,
  SpellResult,
  SpellMetadata,
} from 'spell-engine';
import { ConfigService, PathService, HotkeyBinding } from 'config-engine';
import { ThemeService } from 'theme-engine';
import { SystemAgentService, SystemAgentEvent } from 'system-agent-engine';
import { HotkeyEngine } from 'hotkey-engine';
import { IpcChannel, Theme } from 'shared-types';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

process.env.ELECTRON_ENABLE_LOGGING = 'true';

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

class MainApplication {
  private overlayWindows: Map<number, BrowserWindow> = new Map();
  
  private configService: ConfigService;
  private clipboardService: ClipboardService;
  private themeService: ThemeService;
  private spellService: SpellService;
  private systemAgentService: SystemAgentService;
  private hotkeyEngine: HotkeyEngine;

  private isEditMode = false;
  private pressedKeys: Set<string> = new Set();
  private keyStreamTimeout: NodeJS.Timeout;

  constructor() {
    // The 'ready' event is the entry point.
    app.on('ready', this.onReady.bind(this));

    // Standard window management.
    app.on('window-all-closed', this.onWindowAllClosed.bind(this));
    app.on('activate', this.onActivate.bind(this));
  }

  private async onReady(): Promise<void> {
    await this.initializeServices();
    this.createOverlayWindows();
    this.startSystemAgent();
    this.registerIpcHandlers();
  }

  private onWindowAllClosed(): void {
    // Quit when all windows are closed, except on macOS.
    if (process.platform !== 'darwin') {
      app.quit();
    }
  }

  private onActivate(): void {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
      this.createOverlayWindows();
    }
  }

  private async initializeServices(): Promise<void> {
    this.configService = new ConfigService();
    await this.configService.initialize({
      spells: path.join(app.getAppPath(), 'stock-assets/spells'),
      themes: path.join(app.getAppPath(), 'stock-assets/themes'),
      hotkeys: path.join(app.getAppPath(), 'stock-assets/hotkeys'),
    });

    this.clipboardService = new ClipboardService();

    this.themeService = new ThemeService({
      themesDirectory: this.configService.getThemesDirectory(),
    });

    this.spellService = new SpellService({
      spellsDirectory: this.configService.getSpellsDirectory(),
    });
    
    this.systemAgentService = new SystemAgentService();
    this.hotkeyEngine = new HotkeyEngine({
      systemAgentService: this.systemAgentService,
    });

    this.registerServiceEventHandlers();
    this.registerActions();

    console.log('âœ… User data is stored at:', this.configService.getUserDataPath());
  }
  
  private broadcast(channel: string, ...args: any[]): void {
    for (const window of this.overlayWindows.values()) {
      window.webContents.send(channel, ...args);
    }
  }

  private async createOverlayWindows(): Promise<void> {
    const displays = screen.getAllDisplays();
    const primaryDisplay = screen.getPrimaryDisplay();

    const theme = await this.themeService.loadTheme('default');

    for (const display of displays) {
      const { x, y, width, height } = display.workArea;

      const window = new BrowserWindow({
        x,
        y,
        width,
        height,
        frame: false,
        transparent: true,
        alwaysOnTop: true,
        skipTaskbar: true,
        show: false, // Start hidden
        type: 'splash',
        webPreferences: {
          preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
      });

      window.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
      
      // Set initial state: passthrough clicks
      window.setIgnoreMouseEvents(true, { forward: true });
      
      this.overlayWindows.set(display.id, window);
      
      window.webContents.on('did-finish-load', () => {
        // Determine layout based on whether this is the primary display or not.
        const isPrimary = display.id === primaryDisplay.id;
        const layoutKey = isPrimary ? 'primary' : 'secondary';
        const widgetLayout = theme.layout?.[layoutKey] || [];
        
        window.webContents.send(IpcChannel.SET_THEME, { theme, layout: widgetLayout });

        // Show the window without activating/focusing it.
        window.showInactive();

        // Set initial status for this window
        window.webContents.send(IpcChannel.OVERLAY_SET_STATUS, {
          status: 'idle',
          message: 'Ready',
        });
        
        // Load hotkeys only once after the first window loads
        if (this.overlayWindows.size === 1) {
            this.loadAndRegisterHotkeys();
        }
      });
    }

    // Example of how to send a status update to all overlays
    setTimeout(() => {
      this.broadcast(IpcChannel.OVERLAY_SET_STATUS, {
        status: 'success',
        message: 'Systems nominal.',
      });
    }, 5000);
  }

  private registerActions(): void {
    this.hotkeyEngine.registerAction('spell:run', (binding: HotkeyBinding) => {
      const payload = binding.payload as { spellId: string, metadata: SpellMetadata };
      if (!payload) return;
      
      const { spellId, metadata } = payload;
      
      this.broadcast(IpcChannel.HOTKEY_TRIGGERED, {
        shortcut: binding.shortcut,
        actionId: binding.actionId,
        spellTitle: metadata?.spellTitle || spellId,
      });

      const clipboardContent = this.clipboardService.read();
      this.spellService.run(spellId, { input: clipboardContent }, metadata)
        .catch(err => console.error(`Error running spell '${spellId}':`, err.message));
    });
    
    this.hotkeyEngine.registerAction('overlay:toggle-edit-mode', this.toggleEditMode.bind(this));
    
    // In the future, other actions like 'clipboard:cycle-forward' would be registered here.
  }

  private registerServiceEventHandlers(): void {
    this.spellService.on('spell:start', ({ spellId, metadata }) => {
      this.broadcast(IpcChannel.OVERLAY_SET_STATUS, {
        status: 'processing',
        message: `Casting ${metadata.spellTitle || 'spell'}...`,
      });
    });

    this.spellService.on('spell:success', ({ spellId, metadata, result }) => {
      this.clipboardService.write(result.output);
      this.broadcast(IpcChannel.OVERLAY_SET_STATUS, {
        status: 'success',
        message: 'Spell Complete!',
      });
      this.broadcast(IpcChannel.OVERLAY_SHOW_CONTENT, {
        id: `spell-result-${Date.now()}`,
        type: 'SPELL_RESULT',
        title: metadata.spellTitle || 'Spell Result',
        body: result.output,
        format: 'plaintext',
      });
    });

    this.spellService.on('spell:error', ({ spellId, metadata, error }) => {
      console.error(`Spell [${spellId}] failed:`, error);
      this.broadcast(IpcChannel.OVERLAY_SET_STATUS, {
        status: 'error',
        message: error.message,
      });
    });
  }

  private async loadAndRegisterHotkeys(): Promise<void> {
    // Define the loading order. In the future, this will come from user settings.
    const setsToLoad = ['default', 'navigation'];
    const finalBindings = await this.configService.getHotkeyBindings(setsToLoad);
    this.hotkeyEngine.registerBindings(finalBindings);

    this.systemAgentService.on('error', (error: any) => {
        console.error('System Agent Service Error:', error);
    });
  }

  private startSystemAgent(): void {
    const isDev = !app.isPackaged;
    const resourcesPath = isDev
      ? path.join(app.getAppPath(), 'resources')
      : process.resourcesPath;
    const agentPath = path.join(resourcesPath, 'bin', 'system-agent');

    this.systemAgentService.start(agentPath);

    // Note: Hotkey registration is now handled by the HotkeyEngine
    // and initiated after the window loads.

    this.systemAgentService.on('keypress', (event: SystemAgentEvent) => this.handleKeyEvent(event, 'press'));
    this.systemAgentService.on('keyrelease', (event: SystemAgentEvent) => this.handleKeyEvent(event, 'release'));
  }

  private handleKeyEvent(event: SystemAgentEvent, type: 'press' | 'release'): void {
      this.broadcast(IpcChannel.AGENT_KEY_EVENT, event);
      
      if (type === 'press') {
        this.pressedKeys.add(event.key);
      } else {
        this.pressedKeys.delete(event.key);
      }

      const keys = Array.from(this.pressedKeys).join(' + ');
      
      this.broadcast(IpcChannel.OVERLAY_SHOW_CONTENT, {
        id: 'key-stream',
        type: 'KEY_STREAM',
        keys,
      });

      // Set a timer to clear the key stream after a period of inactivity
      clearTimeout(this.keyStreamTimeout);
      this.keyStreamTimeout = setTimeout(() => {
        this.pressedKeys.clear();
        this.broadcast(IpcChannel.OVERLAY_SHOW_CONTENT, {
          id: 'key-stream',
          type: 'KEY_STREAM',
          keys: '',
        });
      }, 2000);
  }

  private registerIpcHandlers(): void {
    ipcMain.handle(IpcChannel.LOAD_THEME, async (event, themeId: string) => {
      // Note: We now use the singleton instance of the themeService.
      const theme = await this.themeService.loadTheme(themeId);
      // This handler is now more complex, as we need to update all windows
      // with potentially different layouts. For now, we'll just broadcast
      // a full theme update and let each renderer decide its layout.
      // This assumes a full theme change, not just loading one on demand.
      // The logic in createOverlayWindows is more appropriate for initial load.
      // Re-implementing that logic here for hot-reloading themes.
      const primaryDisplay = screen.getPrimaryDisplay();
      for (const [displayId, window] of this.overlayWindows.entries()) {
        const isPrimary = displayId === primaryDisplay.id;
        const layoutKey = isPrimary ? 'primary' : 'secondary';
        const widgetLayout = theme.layout?.[layoutKey] || [];
        window.webContents.send(IpcChannel.SET_THEME, { theme, layout: widgetLayout });
      }
      return theme;
    });
  }

  private toggleEditMode(): void {
    this.isEditMode = !this.isEditMode;
    for (const window of this.overlayWindows.values()) {
      window.setIgnoreMouseEvents(!this.isEditMode, { forward: true });
    }
    this.broadcast(IpcChannel.OVERLAY_EDIT_MODE_CHANGED, { isEditMode: this.isEditMode });

    // When entering edit mode, explicitly focus the primary window.
    if (this.isEditMode) {
      const primaryDisplay = screen.getPrimaryDisplay();
      const primaryWindow = this.overlayWindows.get(primaryDisplay.id);
      if (primaryWindow) {
        primaryWindow.focus();
      }
    }
  }
}

// Kick off the application.
new MainApplication();
