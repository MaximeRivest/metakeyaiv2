import { app, BrowserWindow, screen, ipcMain } from 'electron';
import { spawn } from 'child_process';
import path from 'path';
import { ClipboardService } from 'clipboard-engine';
import {
  SpellService,
  SpellResult,
  SpellMetadata,
} from 'spell-engine';
import { ConfigService, PathService, HotkeyBinding } from 'config-engine';
import { ThemeService } from 'theme-engine';
import { SystemAgentService, SystemAgentEvent } from 'system-agent-engine';
import { HotkeyEngine } from 'hotkey-engine';
import { IpcChannel, Theme } from 'shared-types';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

process.env.ELECTRON_ENABLE_LOGGING = 'true';

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

class MainApplication {
  private mainWindow: BrowserWindow;
  
  private configService: ConfigService;
  private clipboardService: ClipboardService;
  private themeService: ThemeService;
  private spellService: SpellService;
  private systemAgentService: SystemAgentService;
  private hotkeyEngine: HotkeyEngine;

  private keyStream = '';
  private keyStreamTimeout: NodeJS.Timeout;

  constructor() {
    // The 'ready' event is the entry point.
    app.on('ready', this.onReady.bind(this));

    // Standard window management.
    app.on('window-all-closed', this.onWindowAllClosed.bind(this));
    app.on('activate', this.onActivate.bind(this));
  }

  private async onReady(): Promise<void> {
    await this.initializeServices();
    this.createWindow();
    this.startSystemAgent();
    this.registerIpcHandlers();
  }

  private onWindowAllClosed(): void {
    // Quit when all windows are closed, except on macOS.
    if (process.platform !== 'darwin') {
      app.quit();
    }
  }

  private onActivate(): void {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
      this.createWindow();
    }
  }

  private async initializeServices(): Promise<void> {
    this.configService = new ConfigService();
    await this.configService.initialize({
      spells: path.join(app.getAppPath(), 'stock-assets/spells'),
      themes: path.join(app.getAppPath(), 'stock-assets/themes'),
      hotkeys: path.join(app.getAppPath(), 'stock-assets/hotkeys'),
    });

    this.clipboardService = new ClipboardService();

    this.themeService = new ThemeService({
      themesDirectory: this.configService.getThemesDirectory(),
    });

    this.spellService = new SpellService({
      spellsDirectory: this.configService.getSpellsDirectory(),
    });
    
    this.systemAgentService = new SystemAgentService();
    this.hotkeyEngine = new HotkeyEngine({
      systemAgentService: this.systemAgentService,
    });

    this.registerServiceEventHandlers();
    this.registerActions();

    console.log('âœ… User data is stored at:', this.configService.getUserDataPath());
  }
  
  private async createWindow(): Promise<void> {
    const primaryDisplay = screen.getPrimaryDisplay();
    const { x, y, width, height } = primaryDisplay.workArea;

    const windowWidth = 800;
    const windowHeight = 800;

    this.mainWindow = new BrowserWindow({
      width: windowWidth,
      height: windowHeight,
      x: x + width - windowWidth - 20,
      y: y + 20,
      frame: false,
      transparent: true,
      alwaysOnTop: true,
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      },
    });

    this.mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // Set the default theme on startup
    const theme = await this.themeService.loadTheme('default');
    this.mainWindow.webContents.on('did-finish-load', () => {
      this.mainWindow.webContents.send(IpcChannel.SET_THEME, theme);
      this.mainWindow.webContents.send(IpcChannel.OVERLAY_SET_STATUS, {
        status: 'idle',
        message: 'Ready',
      });
      // Now that the window is loaded, we can load and register the hotkeys
      this.loadAndRegisterHotkeys();
    });

    // Example of how to send a status update
    setTimeout(() => {
      this.mainWindow.webContents.send(IpcChannel.OVERLAY_SET_STATUS, {
        status: 'success',
        message: 'Systems nominal.',
      });
    }, 5000);
  }

  private registerActions(): void {
    this.hotkeyEngine.registerAction('spell:run', (payload: { spellId: string, metadata: SpellMetadata }) => {
      const { spellId, metadata } = payload;
      const clipboardContent = this.clipboardService.read();
      this.spellService.run(spellId, { input: clipboardContent }, metadata)
        .catch(err => console.error(`Error running spell '${spellId}':`, err.message));
    });
    
    // In the future, other actions like 'clipboard:cycle-forward' would be registered here.
  }

  private registerServiceEventHandlers(): void {
    this.spellService.on('spell:start', ({ spellId, metadata }) => {
      this.mainWindow.webContents.send(IpcChannel.OVERLAY_SET_STATUS, {
        status: 'processing',
        message: `Casting ${metadata.spellTitle || 'spell'}...`,
      });
    });

    this.spellService.on('spell:success', ({ spellId, metadata, result }) => {
      this.clipboardService.write(result.output);
      this.mainWindow.webContents.send(IpcChannel.OVERLAY_SET_STATUS, {
        status: 'success',
        message: 'Spell Complete!',
      });
      this.mainWindow.webContents.send(IpcChannel.OVERLAY_SHOW_CONTENT, {
        id: `spell-result-${Date.now()}`,
        type: 'SPELL_RESULT',
        title: metadata.spellTitle || 'Spell Result',
        body: result.output,
        format: 'plaintext',
      });
    });

    this.spellService.on('spell:error', ({ spellId, metadata, error }) => {
      console.error(`Spell [${spellId}] failed:`, error);
      this.mainWindow.webContents.send(IpcChannel.OVERLAY_SET_STATUS, {
        status: 'error',
        message: error.message,
      });
    });
  }

  private async loadAndRegisterHotkeys(): Promise<void> {
    // Define the loading order. In the future, this will come from user settings.
    const setsToLoad = ['default', 'navigation'];
    const finalBindings = await this.configService.getHotkeyBindings(setsToLoad);
    this.hotkeyEngine.registerBindings(finalBindings);
  }

  private startSystemAgent(): void {
    const isDev = !app.isPackaged;
    const resourcesPath = isDev
      ? path.join(app.getAppPath(), 'resources')
      : process.resourcesPath;
    const agentPath = path.join(resourcesPath, 'bin', 'system-agent');

    this.systemAgentService.start(agentPath);

    // Note: Hotkey registration is now handled by the HotkeyEngine
    // and initiated after the window loads.

    this.systemAgentService.on('keypress', (event: SystemAgentEvent) => this.handleKeyPress(event));
    this.systemAgentService.on('keyrelease', (event: SystemAgentEvent) => {
      // For now, just forward the event to the renderer.
      this.mainWindow.webContents.send(IpcChannel.AGENT_KEY_EVENT, event);
    });
    this.systemAgentService.on('error', (error: any) => {
        console.error('System Agent Service Error:', error);
    });
  }

  private handleKeyPress(event: SystemAgentEvent): void {
      this.mainWindow.webContents.send(IpcChannel.AGENT_KEY_EVENT, event);
      this.keyStream += event.key.replace('Key', ''); // Clean up the key name
      
      this.mainWindow.webContents.send(IpcChannel.OVERLAY_SHOW_CONTENT, {
        id: 'key-stream',
        type: 'KEY_STREAM',
        keys: this.keyStream,
      });

      // Set a timer to clear the key stream after a period of inactivity
      clearTimeout(this.keyStreamTimeout);
      this.keyStreamTimeout = setTimeout(() => {
        this.keyStream = '';
        this.mainWindow.webContents.send(IpcChannel.OVERLAY_SHOW_CONTENT, {
          id: 'key-stream',
          type: 'KEY_STREAM',
          keys: '',
        });
      }, 2000);
  }

  private registerIpcHandlers(): void {
    ipcMain.handle(IpcChannel.LOAD_THEME, async (event, themeId: string) => {
      // Note: We now use the singleton instance of the themeService.
      const theme = await this.themeService.loadTheme(themeId);
      this.mainWindow.webContents.send(IpcChannel.SET_THEME, theme);
      return theme;
    });
  }
}

// Kick off the application.
new MainApplication();
