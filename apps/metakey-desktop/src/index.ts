import { app, BrowserWindow, screen, ipcMain } from 'electron';
import { spawn } from 'child_process';
import path from 'path';
import { ClipboardService } from 'clipboard-engine';
import {
  SpellService,
  SpellResult,
  SpellMetadata,
} from 'spell-engine';
import { ConfigService, PathService, HotkeyBinding } from 'config-engine';
import { ThemeService } from 'theme-engine';
import { SystemAgentService, SystemAgentEvent } from 'system-agent-engine';
import { HotkeyEngine } from 'hotkey-engine';
import { IpcChannel, Theme, WidgetConfig, DisplayLayout, ThemeLayouts, SpellbookEntry } from 'shared-types';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

process.env.ELECTRON_ENABLE_LOGGING = 'true';

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

class MainApplication {
  private overlayWindows: Map<number, BrowserWindow> = new Map();
  
  private configService: ConfigService;
  private clipboardService: ClipboardService;
  private themeService: ThemeService;
  private spellService: SpellService;
  private systemAgentService: SystemAgentService;
  private hotkeyEngine: HotkeyEngine;

  private isEditMode = false;
  private isSpellbookVisible = false;
  private pressedKeys: Set<string> = new Set();
  private keyStreamTimeout: NodeJS.Timeout;
  private hotkeysRegistered = false;
  private currentTheme: Theme | null = null;
  private currentDisplayCount = 0;
  private isQuitting = false;
  private availableThemes: string[] = ['standard-mmo', 'default', 'magical'];
  private currentThemeIndex = 0;

  constructor() {
    // The 'ready' event is the entry point.
    app.on('ready', this.onReady.bind(this));

    // Standard window management.
    app.on('window-all-closed', this.onWindowAllClosed.bind(this));
    app.on('activate', this.onActivate.bind(this));
    app.on('before-quit', this.onBeforeQuit.bind(this));
  }

  private async onReady(): Promise<void> {
    // Listen for display changes to reload overlays if needed.
    screen.on('display-added', this.handleDisplayChange.bind(this));
    screen.on('display-removed', this.handleDisplayChange.bind(this));
    
    await this.initializeServices();
    this.createOverlayWindows();
    this.startSystemAgent();
    this.registerIpcHandlers();
  }

  private onWindowAllClosed(): void {
    // Quit when all windows are closed, except on macOS.
    if (process.platform !== 'darwin') {
      app.quit();
    }
  }

  private onActivate(): void {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
      this.createOverlayWindows();
    }
  }

  private onBeforeQuit(): void {
    this.isQuitting = true;
    console.log('Cleaning up before quit...');
    this.systemAgentService.stop();
  }

  private handleDisplayChange() {
    // A simple way to handle this is to close existing windows and recreate them.
    // This is robust and ensures the correct layouts are always applied.
    console.log('Display configuration changed. Reloading overlay windows...');
    for (const window of this.overlayWindows.values()) {
        window.close();
    }
    this.overlayWindows.clear();
    this.createOverlayWindows();
  }

  private async initializeServices(): Promise<void> {
    this.configService = new ConfigService();
    await this.configService.initialize({
      spells: path.join(app.getAppPath(), 'stock-assets/spells'),
      themes: path.join(app.getAppPath(), 'stock-assets/themes'),
      hotkeys: path.join(app.getAppPath(), 'stock-assets/hotkeys'),
    });

    this.clipboardService = new ClipboardService();

    this.themeService = new ThemeService({
      themesDirectory: this.configService.getThemesDirectory(),
    });

    this.spellService = new SpellService({
      spellsDirectory: this.configService.getSpellsDirectory(),
    });
    
    this.systemAgentService = new SystemAgentService();
    this.hotkeyEngine = new HotkeyEngine({
      systemAgentService: this.systemAgentService,
    });

    this.registerServiceEventHandlers();
    this.registerActions();

    console.log('âœ… User data is stored at:', this.configService.getUserDataPath());
  }
  
  private broadcast(channel: string, ...args: any[]): void {
    for (const window of this.overlayWindows.values()) {
      window.webContents.send(channel, ...args);
    }
  }

  private findLayoutForDisplayCount(layouts: ThemeLayouts, displayCount: number): DisplayLayout | null {
    let count = displayCount;
    while (count > 0) {
      if (layouts[count.toString()]) {
        return layouts[count.toString()];
      }
      count--;
    }
    // As a final fallback, check for a "default" key.
    return layouts['default'] || null;
  }

  private async createOverlayWindows(): Promise<void> {
    const displays = screen.getAllDisplays();
    this.currentDisplayCount = displays.length;
    const primaryDisplay = screen.getPrimaryDisplay();
    // Create a sorted list of secondary displays to ensure consistent layout assignment.
    const secondaryDisplays = displays
      .filter(d => d.id !== primaryDisplay.id)
      .sort((a, b) => a.bounds.x - b.bounds.x);

    const theme = await this.themeService.loadTheme('standard-mmo');
    this.currentTheme = theme;

    for (const display of displays) {
      const { x, y, width, height } = display.workArea;

      const window = new BrowserWindow({
        x,
        y,
        width,
        height,
        frame: false,
        transparent: true,
        alwaysOnTop: true,
        skipTaskbar: true,
        focusable: false, // Non-focusable by default to prevent stealing focus
        show: false, // Start hidden
        type: process.platform === 'darwin' ? 'panel' : undefined, // Better macOS behavior
        webPreferences: {
          preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
      });

      // Set the window level to keep it above others, including fullscreen apps
      window.setAlwaysOnTop(true, 'floating');
      
      window.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
    
    // Set initial state: passthrough clicks
      window.setIgnoreMouseEvents(true, { forward: true });

      this.overlayWindows.set(display.id, window);
      
      // Handle focus loss - close spellbook if user clicks away
      window.on('blur', () => {
        if (this.isSpellbookVisible) {
          this.toggleSpellbookMode();
        }
      });
      
      window.webContents.on('did-finish-load', async () => {
        const activeLayout = this.findLayoutForDisplayCount(this.currentTheme.layouts, this.currentDisplayCount);
        let widgetLayout: WidgetConfig[] = [];
        
        if (activeLayout) {
          const isPrimary = display.id === primaryDisplay.id;

          if (isPrimary) {
            widgetLayout = activeLayout.primary || [];
          } else {
            const secondaryIndex = secondaryDisplays.findIndex(d => d.id === display.id);
            if (secondaryIndex !== -1 && activeLayout.secondary?.[secondaryIndex]) {
              widgetLayout = activeLayout.secondary[secondaryIndex];
            }
          }
        }
        
        window.webContents.send(IpcChannel.SET_THEME, { theme: this.currentTheme, layout: widgetLayout });

        // Re-assert the "on-top" state before showing the window
        window.setAlwaysOnTop(true, 'floating');
        
        // Show the window without activating/focusing it.
        window.showInactive();
        
        // Force the window to the front on Windows/Linux
        window.moveTop();

        // Set initial status for this window
        window.webContents.send(IpcChannel.OVERLAY_SET_STATUS, {
        status: 'idle',
        message: 'Ready',
      });
        
        // Load hotkeys only once, triggered by the first window to finish loading.
        if (!this.hotkeysRegistered) {
      this.loadAndRegisterHotkeys();
            this.hotkeysRegistered = true;
        }
    });
    }

    // Example of how to send a status update to all overlays
    setTimeout(() => {
      this.broadcast(IpcChannel.OVERLAY_SET_STATUS, {
        status: 'success',
        message: 'Systems nominal.',
      });
    }, 5000);

    ipcMain.handle(IpcChannel.OVERLAY_WIDGET_DRAG_END, (event, { widgetId, x, y }) => {
      if (this.currentTheme) {
        // Update the theme file on disk via the config service
        this.configService.updateWidgetPositionInTheme(this.currentTheme.id, this.currentDisplayCount, widgetId, x, y);

        // Also update the in-memory theme object so we don't need to re-read from disk
        // for other windows or subsequent actions.
        const activeLayout = this.findLayoutForDisplayCount(this.currentTheme.layouts, this.currentDisplayCount);
        if (!activeLayout) return;

        const updateWidget = (widget: WidgetConfig) => {
            if (widget.widgetId === widgetId) {
                widget.x = x;
                widget.y = y;
            }
            return widget;
        };

        if (activeLayout.primary) {
            activeLayout.primary = activeLayout.primary.map(updateWidget);
        }
        if (activeLayout.secondary) {
            // Iterate over each layout in the secondary array and map over its widgets.
            activeLayout.secondary = activeLayout.secondary.map(
                (displayLayout: WidgetConfig[]) => displayLayout.map(updateWidget)
            );
        }
      }
    });
  }

  private registerActions(): void {
    this.hotkeyEngine.registerAction('spell:run', (binding: HotkeyBinding) => {
      const payload = binding.payload as { spellId: string, metadata: SpellMetadata };
      if (!payload) return;
      
      const { spellId, metadata } = payload;
      
      this.broadcast(IpcChannel.HOTKEY_TRIGGERED, {
        shortcut: binding.shortcut,
        actionId: binding.actionId,
        spellTitle: metadata?.spellTitle || spellId,
      });

      this.executeSpell(spellId, metadata);
    });
    
    this.hotkeyEngine.registerAction('overlay:toggle-edit-mode', this.toggleEditMode.bind(this));
    this.hotkeyEngine.registerAction('overlay:toggle-spellbook', this.toggleSpellbookMode.bind(this));
    this.hotkeyEngine.registerAction('theme:cycle', this.cycleTheme.bind(this));
    
    // In the future, other actions like 'clipboard:cycle-forward' would be registered here.
  }

  private registerServiceEventHandlers(): void {
    this.spellService.on('spell:start', (payload) => this.broadcast(IpcChannel.SPELL_START, payload));

    this.spellService.on('spell:success', (payload) => {
      this.clipboardService.write(payload.result.output);
      this.broadcast(IpcChannel.SPELL_SUCCESS, payload);
    });

    this.spellService.on('spell:error', (payload) => {
      console.error(`Spell [${payload.spellId}] failed:`, payload.error);
      this.broadcast(IpcChannel.SPELL_ERROR, payload);
    });
  }

  private async loadAndRegisterHotkeys(): Promise<void> {
    try {
    // Define the loading order. In the future, this will come from user settings.
      const setsToLoad = ['default', 'alternative'];
    const finalBindings = await this.configService.getHotkeyBindings(setsToLoad);
    this.hotkeyEngine.registerBindings(finalBindings);
    } catch (e) {
      console.error("[Main] Failed to load and register hotkeys:", e);
    }
  }

  private startSystemAgent(): void {
    const isDev = !app.isPackaged;
    const resourcesPath = isDev
      ? path.join(app.getAppPath(), 'resources')
      : process.resourcesPath;
    const agentPath = path.join(resourcesPath, 'bin', 'system-agent');

    this.systemAgentService.start(agentPath);

    // Note: Hotkey registration is now handled by the HotkeyEngine
    // and initiated after the window loads.

    this.systemAgentService.on('keypress', (event: SystemAgentEvent) => this.handleKeyEvent(event, 'press'));
    this.systemAgentService.on('keyrelease', (event: SystemAgentEvent) => this.handleKeyEvent(event, 'release'));
    this.systemAgentService.on('error', (error: any) => {
        console.error('System Agent Service Error:', error);
    });
  }

  private handleKeyEvent(event: SystemAgentEvent, type: 'press' | 'release'): void {
      this.broadcast(IpcChannel.AGENT_KEY_EVENT, event);
      
      // If spellbook is visible and this is a key press, check for navigation keys
      if (this.isSpellbookVisible && type === 'press') {
        const navigationKeys = ['UpArrow', 'DownArrow', 'LeftArrow', 'RightArrow', 'Return', 'Escape'];
        if (navigationKeys.includes(event.key)) {
          // Map the system-agent key names to standard names for the spellbook
          const keyMap: { [key: string]: string } = {
            'UpArrow': 'ArrowUp',
            'DownArrow': 'ArrowDown', 
            'LeftArrow': 'ArrowLeft',
            'RightArrow': 'ArrowRight',
            'Return': 'Enter',
            'Escape': 'Escape'
          };
          const mappedKey = keyMap[event.key] || event.key;
          this.broadcast(IpcChannel.SPELLBOOK_NAVIGATE, { key: mappedKey });
          return; // Don't process this key for the key stream display
        }
      }
      
      if (type === 'press') {
        this.pressedKeys.add(event.key);
      } else {
        this.pressedKeys.delete(event.key);
      }

      const keys = Array.from(this.pressedKeys).join(' + ');
      
      this.broadcast(IpcChannel.OVERLAY_SHOW_CONTENT, {
        id: 'key-stream',
        type: 'KEY_STREAM',
        keys,
      });

      // Set a timer to clear the key stream after a period of inactivity
      clearTimeout(this.keyStreamTimeout);
      this.keyStreamTimeout = setTimeout(() => {
        this.pressedKeys.clear();
        this.broadcast(IpcChannel.OVERLAY_SHOW_CONTENT, {
          id: 'key-stream',
          type: 'KEY_STREAM',
          keys: '',
        });
      }, 2000);
  }

  private registerIpcHandlers(): void {
    ipcMain.handle(IpcChannel.SPELLBOOK_CLOSE_REQUEST, () => {
      if (this.isSpellbookVisible) {
        this.toggleSpellbookMode();
      }
    });

    ipcMain.handle(IpcChannel.SPELL_EXECUTE, async (event, { spellId }) => {
      // Hide the spellbook first
      if (this.isSpellbookVisible) {
        await this.toggleSpellbookMode();
      }
      // Then execute the spell
      this.executeSpell(spellId);
    });
  }

  private toggleEditMode(): void {
    this.setInteractive(!this.isEditMode);
  }

  private async cycleTheme(): Promise<void> {
    this.currentThemeIndex = (this.currentThemeIndex + 1) % this.availableThemes.length;
    const newThemeId = this.availableThemes[this.currentThemeIndex];
    
    try {
      const theme = await this.themeService.loadTheme(newThemeId);
      this.currentTheme = theme;
      
      const primaryDisplay = screen.getPrimaryDisplay();
      const secondaryDisplays = screen.getAllDisplays()
        .filter(d => d.id !== primaryDisplay.id)
        .sort((a, b) => a.bounds.x - b.bounds.x);
      
      const activeLayout = this.findLayoutForDisplayCount(theme.layouts, this.currentDisplayCount);
      
      for (const [displayId, window] of this.overlayWindows.entries()) {
        let widgetLayout: WidgetConfig[] = [];
        
        if (activeLayout) {
          const isPrimary = displayId === primaryDisplay.id;
          
          if (isPrimary) {
            widgetLayout = activeLayout.primary || [];
          } else {
            const secondaryIndex = secondaryDisplays.findIndex(d => d.id === displayId);
            if (secondaryIndex !== -1 && activeLayout.secondary?.[secondaryIndex]) {
              widgetLayout = activeLayout.secondary[secondaryIndex];
            }
          }
        }
        
        window.webContents.send(IpcChannel.SET_THEME, { theme, layout: widgetLayout });
      }
      
      // Show a notification about the theme change
      this.broadcast(IpcChannel.OVERLAY_SET_STATUS, {
        status: 'success',
        message: `Theme: ${theme.name}`,
      });
    } catch (error) {
      console.error('Failed to cycle theme:', error);
      this.broadcast(IpcChannel.OVERLAY_SET_STATUS, {
        status: 'error',
        message: 'Failed to change theme',
      });
    }
  }

  private async executeSpell(spellId: string, metadata: SpellMetadata = {}): Promise<void> {
    const clipboardContent = this.clipboardService.read();
    try {
      await this.spellService.run(spellId, { input: clipboardContent }, metadata);
    } catch (err) {
      console.error(`Error running spell '${spellId}':`, err.message);
    }
  }

  private setInteractive(isOn: boolean): void {
    if (this.isQuitting) return;
    this.isEditMode = isOn;
    
    for (const window of this.overlayWindows.values()) {
      window.setIgnoreMouseEvents(!isOn, { forward: true });
      
      if (isOn) {
        // Expanding to edit mode
        window.setFocusable(true);
        // Use higher stacking level to ensure it stays on top during editing
        window.setAlwaysOnTop(true, 'modal-panel');
        // Force window to front for immediate visibility
        window.moveTop();
      } else {
        // Collapsing from edit mode
        window.setFocusable(false);
        // Return to normal overlay stacking level
        window.setAlwaysOnTop(true, 'floating');
      }
    }
    
    this.broadcast(IpcChannel.OVERLAY_EDIT_MODE_CHANGED, { isEditMode: isOn });

    // When entering interactive mode (edit mode OR spellbook), explicitly focus the primary window for immediate keyboard input
    if (isOn) {
      const primaryDisplay = screen.getPrimaryDisplay();
      const primaryWindow = this.overlayWindows.get(primaryDisplay.id);
      if (primaryWindow) {
        primaryWindow.focus();
      }
    }
  }

  private async toggleSpellbookMode(): Promise<void> {
    if (this.isQuitting) return;
    
    // This action now toggles the *interaction mode* for the spellbook.
    this.isSpellbookVisible = !this.isSpellbookVisible;
    this.setInteractive(this.isSpellbookVisible);

    if (this.isSpellbookVisible) {
      // When entering nav mode, send the spell list and menu items.
      const allHotkeys = await this.configService.getHotkeyBindings(['default', 'alternative']);
      const spellHotkeys = allHotkeys.filter(h => h.actionId === 'spell:run');
      
      const spellbookEntries: SpellbookEntry[] = spellHotkeys.map(hotkey => ({
        spellId: hotkey.payload.spellId,
        spellTitle: hotkey.payload.metadata?.spellTitle || hotkey.payload.spellId,
        shortcut: hotkey.shortcut,
      }));
      
      const menuItems = [
        { id: 'spells', label: 'Spells' },
        { id: 'echoes', label: 'Echoes', hotkey: 'E' },
        { id: 'themes', label: 'Themes', hotkey: 'T' },
        { id: 'settings', label: 'Settings' },
      ];
      
      this.broadcast(IpcChannel.SPELLBOOK_UPDATE, { spells: spellbookEntries, menu: menuItems });
    }
    // The renderer will handle deactivating nav mode on its own when focus is lost or Esc is pressed.
  }
}

// Kick off the application.
new MainApplication();
