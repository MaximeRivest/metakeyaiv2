import { app, BrowserWindow, screen, ipcMain, protocol, session } from 'electron';
import { spawn } from 'child_process';
import path from 'path';
import { pathToFileURL } from 'url';
import { ClipboardService } from 'clipboard-engine';
import {
  SpellService,
  SpellResult,
  SpellMetadata,
} from 'spell-engine';
import { ConfigService, PathService, HotkeyBinding } from 'config-engine';
import { ThemeService } from 'theme-engine';
import { SystemAgentService, SystemAgentEvent } from 'system-agent-engine';
import { HotkeyEngine } from 'hotkey-engine';
import { 
  IpcChannel, 
  Theme, 
  WidgetConfig, 
  DisplayLayout, 
  ThemeLayouts, 
  SpellbookEntry, 
  SpellbookMenuItem,
  SpellbookMenuIcon,
  AppMode,
  AppState,
  WidgetStateSource,
  NavigationInputPayload,
  WidgetActionRequestPayload,
  WidgetStateUpdatePayload
} from 'shared-types';
import { AppStateManager } from './AppStateManager';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

process.env.ELECTRON_ENABLE_LOGGING = 'true';

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

class MainApplication {
  private overlayWindows: Map<number, BrowserWindow> = new Map();
  
  private configService: ConfigService;
  private clipboardService: ClipboardService;
  private themeService: ThemeService;
  private spellService: SpellService;
  private systemAgentService: SystemAgentService;
  private hotkeyEngine: HotkeyEngine;
  private appStateManager: AppStateManager;

  private isEditMode = false;
  private pressedKeys: Set<string> = new Set();
  private keyStreamTimeout: NodeJS.Timeout;
  private hotkeysRegistered = false;
  private currentTheme: Theme | null = null;
  private currentDisplayCount = 0;
  private isQuitting = false;
  private availableThemes: string[] = ['standard-mmo', 'default', 'magical'];
  private currentThemeIndex = 0;

  constructor() {
    // Initialize the centralized state manager
    this.appStateManager = new AppStateManager();
    
    // The 'ready' event is the entry point.
    app.on('ready', this.onReady.bind(this));

    // Standard window management.
    app.on('window-all-closed', this.onWindowAllClosed.bind(this));
    app.on('activate', this.onActivate.bind(this));
    app.on('before-quit', this.onBeforeQuit.bind(this));
  }

  private async onReady(): Promise<void> {
    // Set Content Security Policy programmatically to allow our custom theme protocol
    session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
      callback({
        responseHeaders: {
          ...details.responseHeaders,
          'Content-Security-Policy': [
            "default-src 'self' 'unsafe-inline' data:; " +
            "script-src 'self' 'unsafe-eval'; " +
            "style-src 'self' 'unsafe-inline'; " +
            "style-src-elem 'self' 'unsafe-inline' metakey-theme:; " +
            "img-src 'self' data:; " +
            "font-src 'self' data:;"
          ]
        }
      });
    });

    // Register custom protocol for serving theme assets securely
    protocol.registerFileProtocol('metakey-theme', (request, callback) => {
      try {
        // Extract the relative path from the protocol URL
        const url = request.url.replace('metakey-theme://', '');
        
        // Build the safe path within the themes directory
        const themesDir = this.configService.getThemesDirectory();
        const filePath = path.join(themesDir, url);
        
        // Security check: ensure the file is within the themes directory
        if (!filePath.startsWith(themesDir)) {
          console.error('Theme protocol: Attempted to access file outside themes directory:', url);
          callback({ error: -6 }); // GENERIC_FAILURE
          return;
        }
        
        // Serve the file
        callback({ path: filePath });
      } catch (error) {
        console.error('Theme protocol error:', error);
        callback({ error: -6 });
      }
    });

    // Listen for display changes to reload overlays if needed.
    screen.on('display-added', this.handleDisplayChange.bind(this));
    screen.on('display-removed', this.handleDisplayChange.bind(this));
    
    await this.initializeServices();
    this.createOverlayWindows();
    this.startSystemAgent();
    this.registerIpcHandlers();
    this.setupStateManagerListeners();
  }

  private onWindowAllClosed(): void {
    // Quit when all windows are closed, except on macOS.
    if (process.platform !== 'darwin') {
      app.quit();
    }
  }

  private onActivate(): void {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
      this.createOverlayWindows();
    }
  }

  private onBeforeQuit(): void {
    this.isQuitting = true;
    console.log('Cleaning up before quit...');
    this.systemAgentService.stop();
  }

  private handleDisplayChange() {
    // A simple way to handle this is to close existing windows and recreate them.
    // This is robust and ensures the correct layouts are always applied.
    console.log('Display configuration changed. Reloading overlay windows...');
    for (const window of this.overlayWindows.values()) {
        window.close();
    }
    this.overlayWindows.clear();
    this.createOverlayWindows();
  }

  private async initializeServices(): Promise<void> {
    this.configService = new ConfigService();
    await this.configService.initialize({
      spells: path.join(app.getAppPath(), 'stock-assets/spells'),
      themes: path.join(app.getAppPath(), 'stock-assets/themes'),
      hotkeys: path.join(app.getAppPath(), 'stock-assets/hotkeys'),
    });

    this.clipboardService = new ClipboardService();

    this.themeService = new ThemeService({
      themesDirectory: this.configService.getThemesDirectory(),
    });

    this.spellService = new SpellService({
      spellsDirectory: this.configService.getSpellsDirectory(),
    });
    
    this.systemAgentService = new SystemAgentService();
    this.hotkeyEngine = new HotkeyEngine({
      systemAgentService: this.systemAgentService,
    });

    this.registerServiceEventHandlers();
    this.registerActions();

    console.log('âœ… User data is stored at:', this.configService.getUserDataPath());
  }

  private setupStateManagerListeners(): void {
    // Listen for state changes and broadcast to all windows
    this.appStateManager.on('state-changed', (state: AppState) => {
      this.broadcast(IpcChannel.APP_STATE_UPDATE, state);
      this.updateWindowInteractivity(state);
    });

    // Listen for spell execution requests
    this.appStateManager.on('spell-execute-request', (entry: SpellbookEntry) => {
      this.executeSpell(entry.spellId);
    });

    // Listen for mode changes to update hotkey bindings
    this.appStateManager.on('mode-changed', ({ previous, current }) => {
      this.updateHotkeyBindingsForMode(current);
    });
  }

  private updateWindowInteractivity(state: AppState): void {
    const shouldBeInteractive = state.mode !== AppMode.IDLE;
    
    if (shouldBeInteractive !== this.isEditMode) {
      this.setInteractive(shouldBeInteractive);
    }
  }

  private async updateHotkeyBindingsForMode(mode: AppMode): Promise<void> {
    try {
      let bindings: HotkeyBinding[] = [];
      
      // Get base hotkey bindings
      const baseBindings = await this.configService.getHotkeyBindings(['default', 'alternative']);
      
      if (mode === AppMode.IDLE) {
        // In idle mode, use all standard bindings
        bindings = baseBindings;
      } else {
        // In navigation modes, add navigation-specific bindings
        const navigationBindings = this.createNavigationBindings(mode);
        bindings = [...baseBindings, ...navigationBindings];
      }
      
      this.hotkeyEngine.registerBindings(bindings);
    } catch (e) {
      console.error("[Main] Failed to update hotkey bindings for mode:", mode, e);
    }
  }

  private createNavigationBindings(mode: AppMode): HotkeyBinding[] {
    const bindings: HotkeyBinding[] = [
      { shortcut: 'Up', actionId: 'navigation:input', payload: { key: 'ArrowUp', mode } },
      { shortcut: 'Down', actionId: 'navigation:input', payload: { key: 'ArrowDown', mode } },
      { shortcut: 'Left', actionId: 'navigation:input', payload: { key: 'ArrowLeft', mode } },
      { shortcut: 'Right', actionId: 'navigation:input', payload: { key: 'ArrowRight', mode } },
      { shortcut: 'Enter', actionId: 'navigation:input', payload: { key: 'Enter', mode } },
      { shortcut: 'Escape', actionId: 'navigation:input', payload: { key: 'Escape', mode } },
    ];

    if (mode === AppMode.SPELLBOOK) {
      bindings.push(
        { shortcut: 'E', actionId: 'navigation:input', payload: { key: 'E', mode } },
        { shortcut: 'T', actionId: 'navigation:input', payload: { key: 'T', mode } },
        { shortcut: 'W', actionId: 'navigation:input', payload: { key: 'W', mode } },
        { shortcut: 'S', actionId: 'navigation:input', payload: { key: 'S', mode } },
        { shortcut: 'A', actionId: 'navigation:input', payload: { key: 'A', mode } },
        { shortcut: 'D', actionId: 'navigation:input', payload: { key: 'D', mode } }
      );
    }

    return bindings;
  }
  
  private broadcast(channel: string, ...args: any[]): void {
    for (const window of this.overlayWindows.values()) {
      window.webContents.send(channel, ...args);
    }
  }

  private findLayoutForDisplayCount(layouts: ThemeLayouts, displayCount: number): DisplayLayout | null {
    let count = displayCount;
    while (count > 0) {
      if (layouts[count.toString()]) {
        return layouts[count.toString()];
      }
      count--;
    }
    // As a final fallback, check for a "default" key.
    return layouts['default'] || null;
  }

  private async createOverlayWindows(): Promise<void> {
    const displays = screen.getAllDisplays();
    this.currentDisplayCount = displays.length;
    const primaryDisplay = screen.getPrimaryDisplay();
    // Create a sorted list of secondary displays to ensure consistent layout assignment.
    const secondaryDisplays = displays
      .filter(d => d.id !== primaryDisplay.id)
      .sort((a, b) => a.bounds.x - b.bounds.x);

    const theme = await this.themeService.loadTheme('standard-mmo');
    this.currentTheme = theme;

    for (const display of displays) {
      const { x, y, width, height } = display.workArea;

      const window = new BrowserWindow({
        x,
        y,
        width,
        height,
        frame: false,
        transparent: true,
        alwaysOnTop: true,
        skipTaskbar: true,
        focusable: false, // Non-focusable by default to prevent stealing focus
        show: false, // Start hidden
        type: process.platform === 'darwin' ? 'panel' : undefined, // Better macOS behavior
        webPreferences: {
          preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
      });

      // Set the window level to keep it above others, including fullscreen apps
      window.setAlwaysOnTop(true, 'floating');
      
      window.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
    
    // Set initial state: passthrough clicks
      window.setIgnoreMouseEvents(true, { forward: true });

      this.overlayWindows.set(display.id, window);
      
      // Handle focus loss - close navigation modes if user clicks away
      window.on('blur', () => {
        if (this.appStateManager.getState().mode !== AppMode.IDLE) {
          this.appStateManager.setMode(AppMode.IDLE);
        }
      });
      
      window.webContents.on('did-finish-load', async () => {
        const activeLayout = this.findLayoutForDisplayCount(this.currentTheme.layouts, this.currentDisplayCount);
        let widgetLayout: WidgetConfig[] = [];
        
        if (activeLayout) {
          const isPrimary = display.id === primaryDisplay.id;

          if (isPrimary) {
            widgetLayout = activeLayout.primary || [];
          } else {
            const secondaryIndex = secondaryDisplays.findIndex(d => d.id === display.id);
            if (secondaryIndex !== -1 && activeLayout.secondary?.[secondaryIndex]) {
              widgetLayout = activeLayout.secondary[secondaryIndex];
            }
          }
        }
        
        window.webContents.send(IpcChannel.SET_THEME, { theme: this.currentTheme, layout: widgetLayout });

        // Re-assert the "on-top" state before showing the window
        window.setAlwaysOnTop(true, 'floating');
        
        // Show the window without activating/focusing it.
        window.showInactive();
        
        // Force the window to the front on Windows/Linux
        window.moveTop();

        // Send initial application state
        window.webContents.send(IpcChannel.APP_STATE_UPDATE, this.appStateManager.getState());
        
        // Load hotkeys only once, triggered by the first window to finish loading.
        if (!this.hotkeysRegistered) {
      this.loadAndRegisterHotkeys();
            this.hotkeysRegistered = true;
        }
    });
    }

    // Initialize spellbook data
    await this.initializeSpellbookData();

    ipcMain.handle(IpcChannel.OVERLAY_WIDGET_DRAG_END, (event, { widgetId, x, y }) => {
      if (this.currentTheme) {
        // Update the theme file on disk via the config service
        this.configService.updateWidgetPositionInTheme(this.currentTheme.id, this.currentDisplayCount, widgetId, x, y);

        // Also update the in-memory theme object so we don't need to re-read from disk
        // for other windows or subsequent actions.
        const activeLayout = this.findLayoutForDisplayCount(this.currentTheme.layouts, this.currentDisplayCount);
        if (!activeLayout) return;

        const updateWidget = (widget: WidgetConfig) => {
            if (widget.widgetId === widgetId) {
                widget.x = x;
                widget.y = y;
            }
            return widget;
        };

        if (activeLayout.primary) {
            activeLayout.primary = activeLayout.primary.map(updateWidget);
        }
        if (activeLayout.secondary) {
            // Iterate over each layout in the secondary array and map over its widgets.
            activeLayout.secondary = activeLayout.secondary.map(
                (displayLayout: WidgetConfig[]) => displayLayout.map(updateWidget)
            );
        }
      }
    });
  }

  private async initializeSpellbookData(): Promise<void> {
    try {
      const allHotkeys = await this.configService.getHotkeyBindings(['default', 'alternative']);
      const spellHotkeys = allHotkeys.filter(h => h.actionId === 'spell:run');
      
      const spellbookEntries: SpellbookEntry[] = spellHotkeys.map(hotkey => ({
        spellId: hotkey.payload.spellId,
        spellTitle: hotkey.payload.metadata?.spellTitle || hotkey.payload.spellId,
        shortcut: hotkey.shortcut,
      }));
      
      const menuItems: SpellbookMenuItem[] = [
        { id: 'spells', label: 'Spells', icon: SpellbookMenuIcon.SPELLS },
        { id: 'echoes', label: 'Echoes', hotkey: 'E', icon: SpellbookMenuIcon.ECHOES },
        { id: 'themes', label: 'Themes', hotkey: 'T', icon: SpellbookMenuIcon.THEMES },
        { id: 'settings', label: 'Settings', icon: SpellbookMenuIcon.SETTINGS },
      ];
      
      this.appStateManager.updateSpellbook(spellbookEntries, menuItems);
    } catch (error) {
      console.error('Failed to initialize spellbook data:', error);
    }
  }

  private registerActions(): void {
    this.hotkeyEngine.registerAction('spell:run', (binding: HotkeyBinding) => {
      const payload = binding.payload as { spellId: string, metadata: SpellMetadata };
      if (!payload) return;
      
      const { spellId, metadata } = payload;
      
      this.broadcast(IpcChannel.HOTKEY_TRIGGERED, {
        shortcut: binding.shortcut,
        actionId: binding.actionId,
        spellTitle: metadata?.spellTitle || spellId,
      });

      this.executeSpell(spellId, metadata);
    });
    
    this.hotkeyEngine.registerAction('overlay:toggle-edit-mode', this.toggleEditMode.bind(this));
    this.hotkeyEngine.registerAction('overlay:toggle-spellbook', this.toggleSpellbookMode.bind(this));
    this.hotkeyEngine.registerAction('theme:cycle', this.cycleTheme.bind(this));
    
    // Unified navigation action
    this.hotkeyEngine.registerAction('navigation:input', (binding: HotkeyBinding) => {
      const payload = binding.payload as NavigationInputPayload;
      if (!payload) return;
      
      this.handleNavigationInput(payload);
    });
    
    // In the future, other actions like 'clipboard:cycle-forward' would be registered here.
  }

  private handleNavigationInput(payload: NavigationInputPayload): void {
    const { key, mode } = payload;
    
    switch (mode) {
      case AppMode.SPELLBOOK:
        this.handleSpellbookNavigation(key);
        break;
      case AppMode.ECHOES:
        this.handleEchoesNavigation(key);
        break;
      case AppMode.SETTINGS:
        this.handleSettingsNavigation(key);
        break;
    }
  }

  private handleSpellbookNavigation(key: string): void {
    switch (key) {
      case 'ArrowUp':
      case 'W':
        this.appStateManager.navigateSpellbook('up');
        break;
      case 'ArrowDown':
      case 'S':
        this.appStateManager.navigateSpellbook('down');
        break;
      case 'ArrowLeft':
      case 'A':
        this.appStateManager.navigateSpellbook('left');
        break;
      case 'ArrowRight':
      case 'D':
        this.appStateManager.navigateSpellbook('right');
        break;
      case 'Enter':
        this.appStateManager.navigateSpellbook('enter');
        break;
      case 'Escape':
        this.appStateManager.navigateSpellbook('escape');
        break;
      case 'E':
        // Quick navigation to echoes
        this.appStateManager.setMode(AppMode.ECHOES);
        break;
      case 'T':
        // Quick navigation to themes
        this.appStateManager.setMode(AppMode.SETTINGS);
        break;
    }
  }

  private handleEchoesNavigation(key: string): void {
    // TODO: Implement echoes navigation
    if (key === 'Escape') {
      this.appStateManager.setMode(AppMode.IDLE);
    }
  }

  private handleSettingsNavigation(key: string): void {
    // TODO: Implement settings navigation
    if (key === 'Escape') {
      this.appStateManager.setMode(AppMode.IDLE);
    }
  }

  private registerServiceEventHandlers(): void {
    this.spellService.on('spell:start', (payload) => {
      this.appStateManager.setStatus({ status: 'processing', message: `Casting ${payload.metadata?.spellTitle || 'spell'}...` });
    });

    this.spellService.on('spell:success', (payload) => {
      this.clipboardService.write(payload.result.output);
      this.appStateManager.setStatus({ status: 'success', message: 'Spell Complete!' });
      
      // Broadcast widget-specific updates
      this.broadcast(IpcChannel.WIDGET_STATE_UPDATE, {
        target: { stateSource: WidgetStateSource.STATUS },
        state: { 
          type: 'SPELL_RESULT',
          title: payload.metadata?.spellTitle || 'Spell Result',
          body: payload.result.output,
          format: 'plaintext'
        }
      });
    });

    this.spellService.on('spell:error', (payload) => {
      console.error(`Spell [${payload.spellId}] failed:`, payload.error);
      this.appStateManager.setStatus({ status: 'error', message: payload.error.message || 'An unknown error occurred.' });
    });
  }

  private async loadAndRegisterHotkeys(): Promise<void> {
    try {
    // Define the loading order. In the future, this will come from user settings.
      const setsToLoad = ['default', 'alternative'];
    const finalBindings = await this.configService.getHotkeyBindings(setsToLoad);
    this.hotkeyEngine.registerBindings(finalBindings);
    } catch (e) {
      console.error("[Main] Failed to load and register hotkeys:", e);
    }
  }

  private startSystemAgent(): void {
    const isDev = !app.isPackaged;
    const resourcesPath = isDev
      ? path.join(app.getAppPath(), 'resources')
      : process.resourcesPath;
    const agentPath = path.join(resourcesPath, 'bin', 'system-agent');

    this.systemAgentService.start(agentPath);

    // Note: Hotkey registration is now handled by the HotkeyEngine
    // and initiated after the window loads.

    this.systemAgentService.on('keypress', (event: SystemAgentEvent) => this.handleKeyEvent(event, 'press'));
    this.systemAgentService.on('keyrelease', (event: SystemAgentEvent) => this.handleKeyEvent(event, 'release'));
    this.systemAgentService.on('error', (error: any) => {
        console.error('System Agent Service Error:', error);
    });
  }

  private handleKeyEvent(event: SystemAgentEvent, type: 'press' | 'release'): void {
      this.broadcast(IpcChannel.AGENT_KEY_EVENT, event);
      
      if (type === 'press') {
        this.pressedKeys.add(event.key);
      } else {
        this.pressedKeys.delete(event.key);
      }

      const keys = Array.from(this.pressedKeys).join(' + ');
      
      // Update the centralized state
      this.appStateManager.setKeyStream(keys);

      // Set a timer to clear the key stream after a period of inactivity
      clearTimeout(this.keyStreamTimeout);
      this.keyStreamTimeout = setTimeout(() => {
        this.pressedKeys.clear();
        this.appStateManager.setKeyStream('');
      }, 2000);
  }

  private registerIpcHandlers(): void {
    ipcMain.handle(IpcChannel.WIDGET_ACTION_REQUEST, async (event, payload: WidgetActionRequestPayload) => {
      const { widgetId, action, payload: actionPayload } = payload;
      
      switch (action) {
        case 'spell-execute':
          const spellId = actionPayload?.spellId;
          if (spellId) {
            // Hide the spellbook and execute the spell
            this.appStateManager.setMode(AppMode.IDLE);
            this.executeSpell(spellId);
          }
          break;
        case 'close':
          this.appStateManager.setMode(AppMode.IDLE);
          break;
        default:
          console.warn(`Unknown widget action: ${action} for widget: ${widgetId}`);
      }
    });
  }

  private toggleEditMode(): void {
    this.setInteractive(!this.isEditMode);
  }

  private async cycleTheme(): Promise<void> {
    this.currentThemeIndex = (this.currentThemeIndex + 1) % this.availableThemes.length;
    const newThemeId = this.availableThemes[this.currentThemeIndex];
    
    try {
      const theme = await this.themeService.loadTheme(newThemeId);
      this.currentTheme = theme;
      
      const primaryDisplay = screen.getPrimaryDisplay();
      const secondaryDisplays = screen.getAllDisplays()
        .filter(d => d.id !== primaryDisplay.id)
        .sort((a, b) => a.bounds.x - b.bounds.x);
      
      const activeLayout = this.findLayoutForDisplayCount(theme.layouts, this.currentDisplayCount);
      
      for (const [displayId, window] of this.overlayWindows.entries()) {
        let widgetLayout: WidgetConfig[] = [];
        
        if (activeLayout) {
          const isPrimary = displayId === primaryDisplay.id;
          
          if (isPrimary) {
            widgetLayout = activeLayout.primary || [];
          } else {
            const secondaryIndex = secondaryDisplays.findIndex(d => d.id === displayId);
            if (secondaryIndex !== -1 && activeLayout.secondary?.[secondaryIndex]) {
              widgetLayout = activeLayout.secondary[secondaryIndex];
            }
          }
        }
        
        window.webContents.send(IpcChannel.SET_THEME, { theme, layout: widgetLayout });
      }
      
      // Show a notification about the theme change
      this.appStateManager.setStatus({
        status: 'success',
        message: `Theme: ${theme.name}`,
      });
    } catch (error) {
      console.error('Failed to cycle theme:', error);
      this.appStateManager.setStatus({
        status: 'error',
        message: 'Failed to change theme',
      });
    }
  }

  private async executeSpell(spellId: string, metadata: SpellMetadata = {}): Promise<void> {
    const clipboardContent = this.clipboardService.read();
    try {
      await this.spellService.run(spellId, { input: clipboardContent }, metadata);
    } catch (err) {
      console.error(`Error running spell '${spellId}':`, err.message);
    }
  }

  private setInteractive(isOn: boolean): void {
    if (this.isQuitting) return;
    this.isEditMode = isOn;
    
    for (const window of this.overlayWindows.values()) {
      window.setIgnoreMouseEvents(!isOn, { forward: true });
      
      if (isOn) {
        // Expanding to edit mode
        window.setFocusable(true);
        // Use higher stacking level to ensure it stays on top during editing
        window.setAlwaysOnTop(true, 'modal-panel');
        // Force window to front for immediate visibility
        window.moveTop();
      } else {
        // Collapsing from edit mode
        window.setFocusable(false);
        // Return to normal overlay stacking level
        window.setAlwaysOnTop(true, 'floating');
      }
    }
    
    this.broadcast(IpcChannel.OVERLAY_EDIT_MODE_CHANGED, { isEditMode: isOn });

    // When entering interactive mode (edit mode OR navigation mode), explicitly focus the primary window for immediate keyboard input
    if (isOn) {
      const primaryDisplay = screen.getPrimaryDisplay();
      const primaryWindow = this.overlayWindows.get(primaryDisplay.id);
      if (primaryWindow) {
        primaryWindow.focus();
      }
    }
  }

  private async toggleSpellbookMode(): Promise<void> {
    if (this.isQuitting) return;
    
    const currentMode = this.appStateManager.getState().mode;
    const newMode = currentMode === AppMode.SPELLBOOK ? AppMode.IDLE : AppMode.SPELLBOOK;
    
    this.appStateManager.setMode(newMode);
  }
}

// Kick off the application.
new MainApplication();
